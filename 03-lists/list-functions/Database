("(++) :: [a] -> [a] -> [a]","[1,2] ++ [3,4,5] ~> [1,2,3,4,5]\r\n\"Hallo \" ++ show 12 ~> \"Hallo 12\"","H\228ngt zwei Listen aneinander.\r\nWird entsprechend verwendet um Strings zu konkatenieren.")
("take :: Int -> [a] -> [a]","take 3 ['a','b','c','d','e'] ~> ['a','b','c']","Gibt die Anzahl N Elemente zur\252ck")
("drop :: Int -> [a] -> [a]","drop 2 [1, 2, 3, 4, 5] ~> [3, 4, 5","Wirft die ersten N Elemente weg.")
("(!!) :: [a] -> Int -> a","['a','b','c']!!2 ~> 'c'","Gibt das n-te Element zur\252ck")
("last :: [a] -> a","last ['a','b','c'] ~> 'c'","Gibt das letzte Element zur\252ck. ")
("init [a] -> [a]","init ['a','b','c','d'] ~> ['a','b','c']","Gibt alle ausser das letzte Element zur\252ck")
("reverse [a] -> [a]","reverse ['a','b','c'] ~> ['c','b','a']","Dreht eine Liste um.")
("elem :: Eq a => a -> [a] -> Bool","elem 'a' ['a','b','c'] ~> True","Gibt zur\252ck ob das Element in der Liste vorhanden ist. Muss vergleichbar sein")
("maximum, minimum :: Ord a => [a] -> a","maximum [1,4,3] ~> 4\r\nminimum [1,4,3] ~> 1","Gibt das gr\246sste oder kleinste Element zur\252ck")
("sum, product :: Num a => [a] -> a","sum [1, 2, 3]  ~> 6\r\nproduct [2, 2, 4]  ~> 16\r\n","Gibt die Summe/ das Produkt zur\252ck.\r\nDie Listenelemente m\252ssen von einem Zahlen Typen sein (Num).")
("zip :: [a] -> [b] -> [(a,b)]","zip [1, 2, 3] ['a','b','c'] \r\n~>[(1,'a'),(2,'b'), (3,'c')] ","Macht aus zwei Listen eine Liste aus Tuples")
("concat :: [[a]] -> [a]","concat [[1],[2,3],[4]] ~> [1,2,3,4]\r\nconcat [\"abc\",\"def\"] ~> \"abcdef\"","Nimmt eine Liste von Listen und konkateniert sie")
("zipWith :: (a->b->c) -> [a] -> [b] -> [c]","zipWith (+) [1,2,3] [10,11,12] ~> [11,13,15]\r\nzipWith (++) [\"Ha\",\"Ec\"] [\"llo\",\"ho\"] ~> [\"Hallo\",\"Echo\"]","\220bernimmt zwei Listen und kombiniert jeweils zwei Elemente mit der \252bergebenen Funktion.")
